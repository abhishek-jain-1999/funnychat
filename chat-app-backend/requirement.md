# Chat App Backend – Requirements (Draft)

## 1. Project overview

This project is a backend service for a real‑time chat application with user accounts, secure login, and live messaging.  
The backend is built using Spring Boot with Kotlin and exposes REST APIs for signup/signin plus WebSocket endpoints for real‑time chat.  
User accounts are stored in PostgreSQL, chat messages are stored in MongoDB, and Redis is used for caching and WebSocket related data such as pub/sub or presence.

## 2. High‑level goals

The backend should provide a clean, production‑style architecture that a 4+ year backend developer can showcase on GitHub.  
It should demonstrate secure authentication with JWT, real‑time communication with WebSockets, and proper use of relational and NoSQL databases.  
The project should also highlight good engineering practices like tests, documentation, containerization, and Kubernetes deployment.

---

## 3. Tech stack (backend)

- Language: Kotlin with Spring Boot 3.x for writing the server code and business logic.
- HTTP framework: Spring Web (REST controllers for auth and supporting APIs).
- Real‑time: Spring WebSocket with STOMP for real‑time messaging between server and clients.
- Auth and security: Spring Security with JWT tokens for stateless authentication.
- Relational database: PostgreSQL for user accounts, credentials, and other structured auth‑related data.
- NoSQL database: MongoDB for storing chat messages and conversation history in a flexible schema.
- Cache / messaging helper: Redis for caching and for WebSocket‑related pub/sub use cases such as broadcasting between instances.
- Build tool: Gradle (Kotlin DSL) or Maven, generated by Spring Initializr.
- Containerization: Docker image for the backend, later deployed into Kubernetes (kind for local).

---

## 4. Core features

### 4.1 User signup and signin (JWT)

- Allow a new user to create an account using email and password via a REST signup endpoint.
- Allow an existing user to login with valid credentials via a REST signin endpoint.
- On successful signin, issue a signed JWT token that includes user ID and basic claims such as email.
- Store user records in PostgreSQL with hashed passwords and uniqueness enforced on the email field.
- For every protected REST or WebSocket operation, validate the JWT token before allowing access.

### 4.2 WebSocket real‑time chat

- Provide a WebSocket endpoint (for example `/ws/chat`) that clients can connect to after they are authenticated.
- Use STOMP destinations such as `/topic/room.{id}` for public room messages and `/queue/user.{id}` for private messages.
- Require the client to send the JWT token during WebSocket connect (e.g., in headers), and reject connections with invalid or missing tokens.
- Broadcast messages sent by a user to all other subscribers in the same room in real time.
- Use Redis pub/sub when multiple backend instances are running so messages from one instance reach clients connected to another instance.

### 4.3 Message persistence (MongoDB)

- Persist all chat messages in MongoDB so users can view chat history when they open a room.
- Store fields like message ID, room ID, sender user ID, text content, timestamps, and optional metadata such as read status.
- Provide REST endpoints to fetch previous messages for a given room with pagination and time‑based filters.
- Ensure that message writes to MongoDB happen asynchronously or non‑blocking where possible to keep WebSocket latency low.

---

## 5. Data storage design

### 5.1 PostgreSQL (users and auth)

- Table `users` with columns such as `id`, `email`, `password_hash`, `created_at`, and `updated_at`.
- Unique constraint on `email` to prevent duplicate accounts.
- Optional additional tables for user profile data, login audit logs, or refresh tokens if implemented.

### 5.2 MongoDB (messages and rooms)

- Collection `rooms` with fields like `_id`, `name`, `type` (public/private), and participants.
- Collection `messages` with fields such as `_id`, `room_id`, `sender_id`, `content`, `attachments`, and timestamps.
- Index messages by `room_id` and timestamp to support efficient history queries.

### 5.3 Redis (cache and pub/sub)

- Use Redis to store ephemeral data such as active user sessions, online presence flags, or temporary tokens if needed.
- Use Redis pub/sub channels for chat rooms so that each backend instance can publish and subscribe to messages across nodes.
- Optionally cache frequently accessed data like recent message lists or user profile snippets to reduce database load.

---

## 6. API requirements (REST)

### 6.1 Auth endpoints

- `POST /api/auth/signup`: accepts email and password, validates input, creates user in Postgres, and returns basic user info.
- `POST /api/auth/login`: accepts email and password, verifies credentials, and returns a JWT token.
- `GET /api/auth/me`: returns information about the current user based on the JWT token.

### 6.2 Chat and room endpoints

- `POST /api/rooms`: create a new chat room (for example, one‑to‑one or group), only for authenticated users.
- `GET /api/rooms`: list rooms the current user is part of, with basic metadata.
- `GET /api/rooms/{roomId}/messages`: return paginated message history for a room from MongoDB.

All these endpoints should be protected with JWT except signup and login.

---

## 7. WebSocket behaviour requirements

- Only authenticated users with a valid JWT are allowed to establish a WebSocket connection.
- When a user joins a room, the backend should subscribe them to the corresponding STOMP destination.
- When a user sends a message, the backend should validate the payload, persist it to MongoDB, and then broadcast it through WebSocket.
- The backend should handle user join and leave events to support presence indicators or “user is typing” notifications later.

---

## 8. Security requirements

- All passwords must be hashed using a strong algorithm (e.g., bcrypt) before saving to PostgreSQL.
- JWT tokens must be signed with a strong secret or key pair and have configurable expiry times.
- Protect against common attacks like SQL injection and XSS by using Spring Boot defaults and careful input validation.
- Use Spring Security configuration to restrict access to endpoints based on authentication status.

---

## 9. Operational and quality requirements

- The backend should expose health and metrics endpoints using Spring Boot Actuator.
- The application should be containerized with a Dockerfile and optionally a Docker Compose file for Postgres, Redis, and MongoDB.
- Provide clear environment configuration using `application.yml` profiles for local dev and Kubernetes deployment.
- Add logging with structured logs so that it is easy to debug issues in a multi‑instance environment.

---

## 10. Nice‑to‑have extras for a strong GitHub portfolio

These are features and practices that will make the repository look like work from an experienced 4+ year backend engineer.

### 10.1 Architecture and documentation

- Add a simple architecture diagram explaining how clients, backend, Postgres, Redis, Mongo, and Kubernetes interact.
- Create Markdown docs for backend design, API usage, and local setup instructions.
- Include an OpenAPI/Swagger definition for all REST endpoints to show API design quality.

### 10.2 Testing and quality

- Write unit tests for core services such as auth, JWT handling, and message service.
- Add integration tests using Testcontainers for Postgres, Mongo, and Redis to show realistic testing.
- Configure tests to run as part of the build so the project looks CI‑ready.

### 10.3 DevOps and deployment

- Provide a Docker Compose setup for local development with backend, Postgres, Mongo, Redis, and maybe an NGINX reverse proxy.
- Add Kubernetes manifests (Deployments, Services, Ingress) and a `kind` cluster config for local Kubernetes testing.
- Optionally show horizontal scaling of the chat service with Redis pub/sub to demonstrate distributed real‑time handling.

### 10.4 Observability and resilience

- Integrate metrics and health checks using Actuator endpoints and document how to monitor them.
- Add basic rate‑limiting or abuse‑protection around signup/signin to show production awareness.
- Consider adding simple retry or circuit‑breaker logic for database or Redis failures to demonstrate resilience patterns.

### 10.5 Frontend and demo

- Include a minimal web UI (React, Angular, or simple HTML/JS) that connects via WebSocket and uses the auth APIs, even if the focus is on backend.
- Provide a short README section describing demo steps: run containers, open URL, create users, join rooms, and chat.  
